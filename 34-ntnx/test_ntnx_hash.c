/*
 * This file contains the unit tests for the ntnx_hash.c
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ntnx_hash.h"
#include <assert.h>
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>

#define N_THREADS 16
#define N_PROCESS 16
#define N_ITERATIONS 16

/* TODO:
 * 1. Add more valid tests!
 * 2. Avoid hardcoded md5 hash
 * 3. One test should run in one process
 *    may be in serial but this way we
 *    will run all the tests, and get
 *    how many of them are failing or passing
 * 4. Better way is to use unit-test frameworks
 */


#define N_TESTS 1
/*
 * msg[i] = string which has to be computeded
 * md5[i] = md5 hash of the msg[i]
 *
 *
XXX: This hardcoded md5 hash was generated by following command:
ssing214@quads2:~/ntnx$ echo  "hello world" | md5sum
6f5902ac237024bdd0c176cb93063dc4  -
ssing214@quads2:~/ntnx$
 *
 */
static char *msg[N_TESTS] = {"hello world"};
static char *md5[N_TESTS] = {"6f5902ac237024bdd0c176cb93063dc4"};


void test_setup_and_destroy() {
	ntnx_hash_t *ctx = ntnx_hash_setup();
	assert (ctx != NULL);
	assert (ntnx_hash_destroy(ctx) == 0);
}

void test_valid_input_ctx(ntnx_hash_t *ctx) {
	for (int i=0; i<N_TESTS; ++i) {
		char *hash = ntnx_hash_compute(ctx, msg[i], strlen(msg[i]));
		assert (hash != NULL && strlen(hash) == NTNX_HASH_LEN);
		assert (strcmp(hash,md5[i]) == 0);
		free(hash);
	}
}

void test_valid_input() {
	ntnx_hash_t *ctx = ntnx_hash_setup();
	assert (ctx != NULL);
	test_valid_input_ctx(ctx);
	assert (ntnx_hash_destroy(ctx) == 0);
}

void test_invalid_input() {
	ntnx_hash_t *ctx = ntnx_hash_setup();
	assert (ctx != NULL);
	/* XXX: We are testing the error code too!!*/
	errno = 0;
	assert (ntnx_hash_compute(NULL, "abc", 3) == NULL && errno == EINVAL);
	errno = 0;
	assert (ntnx_hash_compute(ctx, NULL, 3) == NULL && errno == EINVAL);
	errno = 0;
	assert (ntnx_hash_compute(ctx, "abc", 0) == NULL && errno == EINVAL);
	errno = 0;
	assert (ntnx_hash_destroy(NULL) == -1 && errno == EINVAL);
	assert (ntnx_hash_destroy(ctx) == 0);
}

void test_basic() {
	test_setup_and_destroy();
	test_valid_input();
	test_invalid_input();
}

void * thread_fn(void*arg) {
	assert (arg != NULL);
	for (int i=0; i<N_ITERATIONS; ++i) {
		test_valid_input_ctx((ntnx_hash_t *) arg);
	}

	return NULL;
}

void test_multi_thread() {
	pthread_t t[N_THREADS];
	/* Share the context */
	ntnx_hash_t *ctx = ntnx_hash_setup();
	assert (ctx != NULL);
	for (int i=0; i<N_THREADS; ++i) {
		pthread_create(&t[i], NULL, thread_fn, ctx);
	}
	for (int i=0; i<N_THREADS; ++i) {
		pthread_join(t[i], NULL);
	}
	assert (ntnx_hash_destroy(ctx) == 0);
}

void test_multi_process() {
	for (int i=0; i<N_PROCESS; ++i) {
		pid_t pid;
		switch ((pid = fork())) {
		case 0:
			for (int i=0; i<N_ITERATIONS; ++i) {
				test_basic();
			}
			return;
		case -1:
			perror("fork()");
			return;
		default:
			/* Parent will do more fork()*/
			break;
		}
	}
}

void test_multi_prcoess_multi_thread() {
	for (int i=0; i<N_PROCESS; ++i) {
		pid_t pid;
		switch ((pid = fork())) {
		case 0:
			test_multi_thread();
			return;
		case -1:
			perror("fork()");
			return;
		default:
			/* Parent will do more fork()*/
			break;
		}
	}
}

int main() {
	test_basic();
	test_multi_thread();
	test_multi_process();
	test_multi_prcoess_multi_thread();
	printf("All tests passed.\n");
	return 0;
}
